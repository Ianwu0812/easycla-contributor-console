{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { BehaviorSubject, combineLatest, from, of, throwError } from 'rxjs';\nimport createAuth0Client from '@auth0/auth0-spa-js';\nimport { catchError, concatMap, shareReplay, tap } from 'rxjs/operators';\nimport * as querystring from 'query-string';\nimport Url from 'url-parse';\nimport { EnvConfig } from '../../config/cla-env-utils';\nimport { AppSettings } from 'src/app/config/app-settings';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/router\";\nimport * as i2 from \"./storage.service\";\nexport let AuthService = /*#__PURE__*/(() => {\n  class AuthService {\n    // Create a local property for login status\n    constructor(router, storageService) {\n      this.router = router;\n      this.storageService = storageService;\n      this.openCLADialog$ = new BehaviorSubject(false);\n      this.auth0Options = {\n        domain: EnvConfig.default['auth0-domain'],\n        clientId: EnvConfig.default['auth0-clientId'],\n        callbackUrl: window.location.origin + '/#/auth'\n      };\n      this.currentHref = window.location.href;\n      this.loading$ = new BehaviorSubject(true);\n      // Create an observable of Auth0 instance of client\n      this.auth0Client$ = from(createAuth0Client({\n        domain: this.auth0Options.domain,\n        client_id: this.auth0Options.clientId\n      })).pipe(shareReplay(1),\n      // Every subscription receives the same shared value\n      catchError(err => {\n        this.loading$.next(false);\n        return throwError(err);\n      }));\n      // Define observables for SDK methods that return promises by default\n      // For each Auth0 SDK method, first ensure the client instance is ready\n      // concatMap: Using the client instance, call SDK method; SDK returns a promise\n      // from: Convert that resulting promise into an observable\n      this.isAuthenticated$ = this.auth0Client$.pipe(concatMap(client => from(client.isAuthenticated())), tap(res => {\n        this.loggedIn = res;\n      }));\n      this.handleRedirectCallback$ = this.auth0Client$.pipe(concatMap(client => from(client.handleRedirectCallback(this.currentHref))));\n      // Create subject and public observable of user profile data\n      this.loggedIn = false;\n      this.userProfileSubject$ = new BehaviorSubject(null);\n      this.userProfile$ = this.userProfileSubject$.asObservable();\n      this.initializeApplication();\n    }\n    initializeApplication() {\n      return __awaiter(this, void 0, void 0, function* () {\n        // On initial load, check authentication state with authorization server\n        // Set up local auth streams if user is already authenticated\n        const params = this.currentHref;\n        if (params.includes('code=') && params.includes('state=')) {\n          console.log('Auth0 code and state are found.');\n          this.handleAuthCallback();\n          return;\n        }\n        yield this.localAuthSetup();\n        this.handlerReturnToAferlogout();\n      });\n    }\n    handlerReturnToAferlogout() {\n      const hasGerrit = JSON.parse(this.storageService.getItem(AppSettings.HAS_GERRIT));\n      this.storageService.removeItem(AppSettings.AUTH_DATA);\n      if (!hasGerrit) {\n        const {\n          query\n        } = querystring.parseUrl(this.currentHref);\n        const returnTo = query.returnTo;\n        if (returnTo) {\n          const target = this.getTargetRouteFromReturnTo(returnTo);\n          this.router.navigate([target]);\n        }\n      } else {\n        this.login();\n      }\n    }\n    // When calling, options can be passed if desired\n    // https://auth0.github.io/auth0-spa-js/classes/auth0client.html#getuser\n    getUser$(options) {\n      return this.auth0Client$.pipe(concatMap(client => from(client.getUser(options))), tap(user => {\n        this.setSession(user);\n        this.setUserInHeader(user);\n        this.userProfileSubject$.next(user);\n      }));\n    }\n    setUserInHeader(user) {\n      const lfHeaderEl = document.getElementById('lfx-header-v2');\n      lfHeaderEl.authuser = user;\n    }\n    login() {\n      // Need to increase timeout to 1500 as for slower network it gives an error\n      // Cannot read property 'querySelector' of null\n      // TODO: verify this still works\n      setTimeout(() => {\n        const button = document.querySelector('#lfx-header-v2').shadowRoot.querySelector('app-lfx-user-icon');\n        if (button) {\n          button.click();\n        }\n      }, 1500);\n    }\n    logout() {\n      const {\n        query,\n        fragmentIdentifier\n      } = querystring.parseUrl(window.location.href, {\n        parseFragmentIdentifier: true\n      });\n      const qs = Object.assign(Object.assign({}, query), {\n        returnTo: window.location.href\n      });\n      const searchStr = querystring.stringify(qs);\n      const searchPart = searchStr ? `?${searchStr}` : '';\n      const fragmentPart = fragmentIdentifier ? `#${fragmentIdentifier}` : '';\n      const request = {\n        client_id: this.auth0Options.clientId,\n        returnTo: `${window.location.origin}${searchPart}${fragmentPart}`\n      };\n      this.auth0Client$.subscribe(client => client.logout(request));\n    }\n    getTokenSilently$(options) {\n      return this.auth0Client$.pipe(concatMap(client => from(client.getTokenSilently(options))));\n    }\n    getIdToken$(options) {\n      return this.auth0Client$.pipe(\n      // *info: if getIdToken fails , just return empty in the catchError\n      concatMap(client => from(client.getIdTokenClaims(options))), concatMap(claims => of(claims && claims.__raw || '')), catchError(() => of('')));\n    }\n    localAuthSetup() {\n      return __awaiter(this, void 0, void 0, function* () {\n        // This should only be called on app initialization\n        // Set up local authentication streams\n        const checkAuth$ = this.isAuthenticated$.pipe(concatMap(loggedIn => {\n          if (loggedIn) {\n            // If authenticated, get user and set in app\n            // NOTE: you could pass options here if needed\n            this.loading$.next(false);\n            return this.getUser$();\n          }\n          this.auth0Client$.pipe(\n          // https://auth0.com/docs/libraries/auth0-single-page-app-sdk#get-access-token-with-no-interaction\n          // *info: Allow check user session in public pages to avoid redirecting to login page\n          concatMap(client => from(client.getTokenSilently({\n            ignoreCache: true\n          }))), concatMap(() => this.getUser$()), concatMap(user => {\n            if (user) {\n              return this.isAuthenticated$;\n            }\n            this.checkUserSessionByCookie();\n            return of(null);\n          }), catchError(() => {\n            // *info: by pass error, no needed, it is login_required\n            this.checkUserSessionByCookie();\n            return of(null);\n          })).subscribe(() => {\n            this.loading$.next(false);\n          });\n          // If not authenticated, return stream that emits 'false'\n          return of(loggedIn);\n        }));\n        checkAuth$.subscribe();\n      });\n    }\n    checkUserSessionByCookie() {\n      const cookieName = `auth-${this.auth0Options.domain}`;\n      const cookieExists = this.getCookie(cookieName);\n      if (cookieExists) {\n        console.log('triggering login by cookies ');\n        this.login();\n        return;\n      }\n    }\n    getCookie(cname) {\n      const name = cname + '=';\n      const decodedCookie = decodeURIComponent(document.cookie);\n      const ca = decodedCookie.split(';');\n      for (let i = 0; i < ca.length; i++) {\n        let c = ca[i];\n        while (c.charAt(0) === ' ') {\n          c = c.substring(1);\n        }\n        if (c.indexOf(name) === 0) {\n          return c.substring(name.length, c.length);\n        }\n      }\n      return '';\n    }\n    getTargetRouteFromAppState(appState) {\n      if (!appState) {\n        return '/';\n      }\n      const {\n        returnTo,\n        target,\n        targetUrl\n      } = appState;\n      return this.getTargetRouteFromReturnTo(returnTo) || target || targetUrl || '/';\n    }\n    getTargetRouteFromReturnTo(returnTo) {\n      if (!returnTo) {\n        return '';\n      }\n      const {\n        fragmentIdentifier\n      } = querystring.parseUrl(returnTo, {\n        parseFragmentIdentifier: true\n      });\n      if (fragmentIdentifier) {\n        return fragmentIdentifier;\n      }\n      const {\n        pathname\n      } = new Url(returnTo);\n      return pathname || '/';\n    }\n    handleAuthCallback() {\n      // Call when app reloads after user logs in with Auth0\n      const params = this.currentHref;\n      if (params.includes('code=') && params.includes('state=')) {\n        let targetRoute = ''; // Path to redirect to after login processsed\n        const authComplete$ = this.handleRedirectCallback$.pipe(\n        // Have client, now call method to handle auth callback redirect\n        tap(cbRes => {\n          targetRoute = this.getTargetRouteFromAppState(cbRes.appState);\n        }), concatMap(() => combineLatest([this.getUser$(), this.isAuthenticated$])), catchError(err => {\n          console.log('Error occured while getting Auth0 data ', {\n            err\n          });\n          this.checkUserSessionByCookie();\n          return of('invalid_state');\n        }));\n        // Subscribe to authentication completion observable\n        // Response will be an array of user and login status\n        authComplete$.subscribe(message => {\n          this.loading$.next(false);\n          if (message === 'invalid_state') {\n            console.log('triggering login by invali_state ');\n            this.login();\n            return;\n          }\n          if (!targetRoute) {\n            return this.router.navigateByUrl('/auth');\n          }\n          const url = '/auth?targetRoute=' + (targetRoute || '');\n          this.router.navigateByUrl(url);\n        });\n      }\n    }\n    /* Extra method added */\n    setSession(authResult) {\n      const sessionData = {\n        userid: authResult.nickname,\n        user_email: authResult.email,\n        user_name: authResult.name\n      };\n      this.storageService.setItem(AppSettings.AUTH_DATA, sessionData);\n    }\n  }\n  AuthService.ɵfac = function AuthService_Factory(t) {\n    return new (t || AuthService)(i0.ɵɵinject(i1.Router), i0.ɵɵinject(i2.StorageService));\n  };\n  AuthService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: AuthService,\n    factory: AuthService.ɵfac,\n    providedIn: 'root'\n  });\n  return AuthService;\n})();","map":null,"metadata":{},"sourceType":"module"}